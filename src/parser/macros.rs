#[macro_export]
macro_rules! count_idents {
    (@unit $id:ident) => {()};

    ($($id:ident)*) => {
        <[()]>::len(&[$($crate::count_idents!(@unit $id)),*])
    };
}

#[macro_export]
macro_rules! parser {
    (
        with ($message:ident, $arguments:ident) {
            // Technically, the `$rest` part is incorrect since it allows
            // `command(, ..rest)` and `command(a, b ..rest)`.
            // I can probably live with that.
            $($command:ident ($($arg_name:ident),* $($(,)? ..$rest:ident)? $(,)?) $blk:block $(,)?)*
        }
    ) => {
        static PARSER: SyncLazy<Parser<'static>> = SyncLazy::new(|| {
            let mut config = CommandParserConfig::new();
            config.add_prefix("~");
            config.add_command("help", true);
            $(config.add_command(stringify!($command), true);)*

            Parser::new(config)
        });

        /// Parses a message, checking if it has a command.
        /// This function is currently generated by a macro.
        pub async fn parse_command($message: &MessageCreate) -> Option<String> {
            use debug_unreachable::debug_unreachable;

            if $message.author.id.0 == *BOT_USER_ID {
                return None;
            }

            match PARSER.parse(&$message.content) {
                Some(Command {
                    name, $arguments, ..
                }) => Some(match name {
                    "help" => {
                        concat!(
                            "Available commands:\n",
                            $(
                                "    ~",
                                stringify!($command),
                                $(" ", stringify!($arg_name),)*
                                $(" ", stringify!($rest), "...",)?
                                "\n",
                            )*
                            "\n",
                            "`argument...` denotes a \"rest\" argument that consumes all arguments from then ",
                            "on, including spaces.\n",
                            "Non-rest arguments can be surrounded by quotes to allow for spaces.\n",
                            "For example, `~create \"Hata no Kokoro\" https://example.com/kokoro.png koko:` ",
                            "will create a character named \"Hata no Kokoro\".\n",
                            "Note that as a side effect of this, any quotes in a rest argument will be removed.",
                        ).to_owned()
                    },

                    $(stringify!($command) => {
                        // Constants are used to try and prod the compiler to
                        // optimize this code
                        /// Number of non-$rest arguments
                        const NUM_ARGS: usize = $crate::count_idents!($($arg_name)*);
                        /// 1 if ..$rest is given, 0 otherwise
                        const REST: usize = $crate::count_idents!($($rest)?);
                        const HAS_REST: bool = REST != 0;

                        static USAGE: SyncLazy<String> = SyncLazy::new(|| format!(
                            "~{} takes {} argument{}{}{}.",
                            stringify!($command),
                            NUM_ARGS + REST,
                            // TODO: hacky?
                            if NUM_ARGS + REST == 1 { "" } else { "s" },
                            if NUM_ARGS + REST == 0 { "" } else { ":" },
                            concat!($(" `", stringify!($arg_name), "`",)* $(" `", stringify!($rest), "...`")?),
                        ));

                        let mut arguments_vec = $arguments
                            .clone()
                            .collect::<Vec<_>>();

                        if
                            // If we don't have a `..$rest` argument,
                            // we just need `NUM_ARGS` arguments.
                            (!HAS_REST && arguments_vec.len() != NUM_ARGS)
                            // Otherwise, we need at least `NUM_ARGS + 1` (but
                            // we can take more!).
                            || (HAS_REST && arguments_vec.len() < NUM_ARGS + 1)
                        {
                            return Some(USAGE.clone());
                        }

                        $(
                            let $rest = $arguments
                                .clone()
                                .skip(NUM_ARGS)
                                .intersperse(" ")
                                .collect::<String>();
                        )?

                        // This is done here rather than
                        // before collecting into the `Vec`
                        // to check for excess arguments.
                        arguments_vec.truncate(NUM_ARGS);

                        if let [$($arg_name),*] = arguments_vec.as_slice() {
                            $blk
                        } else {
                            // SAFETY: there should be `NUM_ARGS` `arg_name`s and
                            // `NUM_ARGS` should be equal to `arguments_vec.len()`,
                            // so the slice pattern match should be infallible
                            unsafe {
                                debug_unreachable!()
                            }
                        }
                    },)*

                    // SAFETY: due to how the macro is crafted, the parser will
                    // only return `Some(Command)` for `~help` or for any $command
                    // provided in the macro, so the above match arms should match
                    // every possible case.
                    _ => unsafe { debug_unreachable!() },
                }),

                _ => None,
            }
        }
    };
}
